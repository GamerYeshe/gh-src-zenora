// Zenora Multi Tool :: Written by Aphex, GOLDEN & NocturnalVirus

// READ! - Notes - READ!
// Use program_name -h (ex: zx -h) for shortcut commands. Working on this more.
// Remember to copy the IP addresses and note passwords and other important information often because this program uses clear_screen for the menus
// Program begins under MainMenu()
// Always clear logs

// IMPROVEMENT GOALS:
// 1) 

COLOUR_WHITE = "<color=#ffffff>"
COLOUR_BLUE = "<color=#0080ff>"
COLOUR_GREEN = "<color=#3d7932>"
COLOUR_ORANGE = "<color=#fd573a>"
COLOUR_RED = "<color=#ff0000>"
COLOUR_PURPLE = "<color=#c471dc>"
COLOUR_YELLOW = "<color=#f1ef31>"

PORT_FTP = 21
PORT_SSH = 22

version_number = "3.3"

// Import required libraries
pkg = get_custom_object
if not pkg.hasIndex("crypto") then
	crypto = include_lib("/lib/crypto.so")
	if not crypto then crypto = include_lib(current_path + "/crypto.so")
	if not crypto then
		print(COLOUR_RED + "Error: Cannot find crypto library. Please ensure crypto.so is in the lib folder or current directory.</color>")
		exit
	end if
else
	crypto = pkg.crypto
end if

// Access Control System
DEVELOPER_KEYS = [] // Will store valid developer keys
SALT_KEY = "ZenoraX" // Salt for password encryption

// Initialize global authentication state
if not globals.hasIndex("is_authenticated") then globals.is_authenticated = false

// Add this near the top with other globals
CONFIG_DEFAULT = {
    "password": "",
    "retry_count": "0"}

// Add these helper functions for retry count obfuscation
EncodeRetryCount = function(count)
    // Convert count to a complex string that looks like a hash
    base = "attempt_verification_" + str(count) + "_sequence"
    return CustomHash(base)
end function

DecodeRetryCount = function(encoded)
    if not encoded then return 0
    // Known hashes for 0-3 attempts
    known_hashes = {}
    for i in range(0, 3)
        known_hashes[EncodeRetryCount(i)] = i
    end for
    if known_hashes.hasIndex(encoded) then
        return known_hashes[encoded]
    end if
    return 0
end function

SaveConfig = function(config_data)
    computer = get_shell.host_computer
    // Encode retry count as a hash
    retry_hash = EncodeRetryCount(config_data.retry_count.to_int)
    // Format the config data as password:retry_hash
    config_str = config_data.password + ":" + retry_hash
    config_file = computer.File(current_path + "/cnf.zx")
    if not config_file then
        computer.touch(current_path, "cnf.zx")
        config_file = computer.File(current_path + "/cnf.zx")
    end if
    config_file.set_content(config_str)
end function

LoadConfig = function()
    computer = get_shell.host_computer
    config_file = computer.File(current_path + "/cnf.zx")
    if not config_file then return CONFIG_DEFAULT
    
    encrypted = config_file.get_content
    if not encrypted then return CONFIG_DEFAULT
    
    decrypted = {}
    parts = encrypted.split(":")
    if parts.len >= 2 then
        decrypted.password = parts[0]
        // Decode the retry hash back to a count
        decrypted.retry_count = str(DecodeRetryCount(parts[1]))
        return decrypted
    end if
    
    return CONFIG_DEFAULT
end function

GetOwnerHash = function()
	computer = get_shell.host_computer
	passwd_file = computer.File("/etc/passwd")
	if not passwd_file or not passwd_file.has_permission("r") then return null
	
	owner_line = passwd_file.get_content.split("\n")[0]
	if not owner_line then return null
	
	parts = owner_line.split(":")
	if parts.len < 2 then return null
	
	return parts[1]
end function

// Custom encryption/decryption functions
CustomEncrypt = function(text)
    if not text then return null
    // Add salt and use double hashing for better security
    salted = text + SALT_KEY
    hash1 = crypto.md5(salted)
    hash2 = crypto.hash(salted)
    return hash1 + ":" + hash2
end function

CustomDecrypt = function(encrypted)
    if not encrypted then return null
    // Since we're using a one-way hash, we can only verify, not decrypt
    // This is a placeholder that always returns null
    return null
end function

CustomHash = function(text)
    if not text then return null
    
    // Get user and computer specific information
    computer = get_shell.host_computer
    user_salt = computer.get_name + active_user + computer.local_ip
    
    // Add user-specific salt to the text
    salted_text = text + user_salt
    
    // Initialize hash value
    hash = 0
    
    // Process each character
    for i in range(0, salted_text.len-1)
        // Get character code and position-based multiplier
        char_code = salted_text[i].code
        multiplier = (i + 1) * 31
        
        // Add to hash with position-based weighting
        hash = hash + (char_code * multiplier)
        
        // Ensure we stay within reasonable number size
        hash = hash % 999999999
    end for
    
    // Convert to hex string for consistent format
    result = ""
    hex = "0123456789abcdef"
    temp = hash
    while temp > 0
        result = hex[temp % 16] + result
        temp = floor(temp / 16)
    end while
    
    // Pad with zeros if needed
    while result.len < 8
        result = "0" + result
    end while
    
    return result
end function

HashPassword = function(password, owner_hash)
    if not password or not owner_hash then return null
    // Create a unique salt using owner_hash and our SALT_KEY
    unique_salt = owner_hash + SALT_KEY
    
    // Hash the password multiple times with different salts
    hash1 = CustomHash(password + unique_salt)
    hash2 = CustomHash(hash1 + SALT_KEY)
    final_hash = CustomHash(hash2 + owner_hash)
    
    return final_hash
end function

EncryptPassword = function(password)
    // Get owner's hash
    owner_hash = GetOwnerHash()
    if not owner_hash then 
        print(COLOUR_RED + "Error: Could not get owner's password hash. Access control may be compromised.</color>")
        exit
    end if
    
    // Hash the password with owner_hash as additional salt
    return HashPassword(password, owner_hash)
end function

DecryptPassword = function(encrypted)
    // Since we're using a one-way hash, we can't decrypt
    // This function is kept for compatibility
    return null
end function

CleanupZX = function()
    computer = get_shell.host_computer
    // Delete config file
    config = computer.File(current_path + "/cnf.zx")
    if config then config.delete
    
    // Delete all ZX related directories and their contents
    files = computer.File(current_path).get_files + computer.File(current_path).get_folders
    for file in files
        if file.is_folder then
            // Check if folder contains exploit_log or reconnect scripts
            if file.get_files.len > 0 and file.get_files[0].name.indexOf("exploit_log") != null then
                file.delete
            end if
        else if file.path.indexOf(".zx") != null or file.path.indexOf("zx_") != null then
            file.delete
        end if
    end for
    
    print(COLOUR_RED + "\nAccess violation. Cleaning up...</color>")
    wait(1)
    
    // Delete the zx executable itself last
    program = computer.File(program_path)
    if program then program.delete
    
    exit
end function

CheckFirstRun = function()
    computer = get_shell.host_computer
    config = LoadConfig()
    
    // Show setup if no config file or if there's no password set
    if not computer.File(current_path + "/cnf.zx") or not config.password then
        clear_screen
        ascii_art = ["@#$%&*> @#   #$ ",
                    "   x@     £# ¢#  ",
                    "  ¤#       #@#   ",
                    " @#       #¢ ¥#  ",
                    "M$&%#@   ¢#   #@ "]
        
        for line in ascii_art
            print(COLOUR_PURPLE + line + "</color>")
        end for
        
        attempts = config.retry_count.to_int()
        while attempts < 3
            print(char(10) + COLOUR_BLUE + "Enter master key to continue:")
            master_key = user_input(COLOUR_ORANGE + "Key> ")
            
            // Verify master key
            if master_key != "ZENORA_DEV_2024" then
                attempts = attempts + 1
                config = {"password": "", "retry_count": str(attempts)}
                SaveConfig(config)
                if attempts >= 3 then
                    CleanupZX()
                end if
                print(COLOUR_RED + "Access denied.</color>")
                wait(2)
                continue
            end if
            
            // Master key correct, now set up access key
            print(COLOUR_WHITE + "\nSet access key:")
            dev_password = user_input(COLOUR_ORANGE + "Key> ")
            
            if not dev_password then
                print(COLOUR_RED + "No key provided.</color>")
                wait(2)
                continue
            end if
            
            // Save encrypted password and reset retry count
            encrypted = EncryptPassword(dev_password)
            if encrypted then
                config = {"password": encrypted, "retry_count": "0"}
                SaveConfig(config)
                print(COLOUR_GREEN + "\nAccess key set successfully.</color>")
                globals.is_authenticated = true
                wait(1)
                clear_screen
                return
            end if
            break
        end while
    end if
end function

VerifyPassword = function(stored_hash, input_password)
    // For password verification, we need to hash the input the same way
    owner_hash = GetOwnerHash()
    if not owner_hash then
        ErrorMessage("Could not get owner hash for verification!")
        wait(2)
        return false
    end if
    
    // Hash the input password and compare
    input_hash = HashPassword(input_password, owner_hash)
    return input_hash == stored_hash
end function

VerifyDeveloperKey = function(key)
    config = LoadConfig()
    if not config.password then return false
    return VerifyPassword(config.password, key)
end function

RequestAccess = function()
    // If already authenticated this session, skip the check
    if globals.is_authenticated then return true
    
    config = LoadConfig()
    attempts = config.retry_count.to_int()
    while attempts < 3
        clear_screen
        print(COLOUR_YELLOW + "<b>-- Access Control --</b></color>")
        print(COLOUR_WHITE + "Please enter your access key:")
        key = user_input(COLOUR_ORANGE + "Key> ")
        
        if VerifyDeveloperKey(key) then
            // Reset retry count on successful login
            config.retry_count = "0"
            SaveConfig(config)
            print(COLOUR_GREEN + "Access granted.</color>")
            wait(1)
            globals.is_authenticated = true
            return true
        else
            attempts = attempts + 1
            config.retry_count = str(attempts)
            SaveConfig(config)
            if attempts >= 3 then
                CleanupZX()
            end if
            print(COLOUR_RED + "Invalid key.</color>")
            wait(2)
        end if
    end while
end function

ErrorMessage = function(message, ext=false) // ext == true | exit the program
	print(COLOUR_RED + "Error: "+ COLOUR_WHITE + message + "</color>")
	if ext then exit()
end function

WarningMessage = function(message)
	print(COLOUR_ORANGE + "Warning: "+ COLOUR_WHITE + message + "</color>")
end function

InfoMessage = function(message)
	print(COLOUR_BLUE + "Info: " + COLOUR_WHITE + message + "</color>")
end function

SyntaxMessage = function(message)
	print(COLOUR_PURPLE + "Syntax: " + COLOUR_WHITE + message + "</color>")
end function

RequestInput = function(message, customText="")
	print(COLOUR_WHITE + message + "</color>")
	path_dir = current_path
	// request_input = user_input(COLOUR_WHITE + path_dir[1:] + "/$" + active_user + "> " + COLOUR_ORANGE)
	request_input = user_input(COLOUR_WHITE + "=> " + COLOUR_ORANGE + customText) // Experimental
	return request_input
end function

main_input = null
ip_addr = null
port_num = null
opt_var = null
metaLib = null
is_command = false
file_info = {
	"name": null,
	"path": null,
	"content": null}
exploit_data = { 
	"memAddress": null, 
	"unsecValue": null, 
	"rootPass": null, 
	"passContent": null, 
	"files": []}

pkg = get_custom_object
comp = get_shell.host_computer.File("/")

// Import the main shell else get_shell
if not pkg.hasIndex("shell") then _shell = get_shell else _shell = pkg.shell // Imports the main shell else get_shell
_computer = _shell.host_computer

// include "metaxploit.so"
if not pkg.hasIndex("metaxploit") then
	metaxploit = include_lib("/lib/metaxploit.so")
	if not metaxploit then metaxploit = include_lib(current_path + "/metaxploit.so") // include from current directory if "metaxploit.so" not found in /lib
	if not metaxploit then ErrorMessage("Cannot find metaxploit library in lib or current path folder.", true)
else
	metaxploit = pkg.metaxploit
end if

// include "crypto.so"
if not pkg.hasIndex("cryptools") then
	cryptools = include_lib("/lib/crypto.so")
	if not cryptools then cryptools = include_lib(current_path + "/crypto.so") // include from current directory if "crypto.so" not found in /lib
	if not cryptools then ErrorMessage("Cannot find crypto library in lib or current path folder.", true)
else
	cryptools = pkg.cryptools
end if

// check if string starts with substring
string.startswith = function(self, substring)
	if substring.len > self.len then return false
	if substring.len == self.len then return substring == self
	return substring == self[:substring.len]
end function
// check if string ends with substring
string.endswith = function(self, substring)
	if substring.len > self.len then return false
	if substring.len == self.len then return substring == self
	return substring == self[-substring.len:]
end function


// get the current path for example <user>@<device_name>:/home/user$>
get_path = function()
	host_comp = get_shell.host_computer
	user = active_user
	// Color user_name depending on privilage
	if user == "root" then
		user = COLOUR_RED + user + "</color>"
	else if user != "guest" then
		user = COLOUR_BLUE + user + "</color>"
	else
		user = "<color=grey>" + user + "</color>"
	end if
	// return user_input(COLOUR_WHITE + path_dir[1:] + "/$" + active_user + "> " + COLOUR_ORANGE)
	 return user + COLOUR_WHITE + "@" + COLOUR_GREEN + host_comp.get_name + COLOUR_WHITE + ":" + current_path + "$> " + COLOUR_ORANGE // Experimental
end function

StartTerminal = function(shell, bypass_question=false)
	// bypass the question
	if not bypass_question then
		terminal_input = RequestInput("Start terminal? y/n")
	else
		terminal_input = "y"
	end if
	if terminal_input.lower != "y" then
		ContinueProgram()
	end if
	shell.start_terminal
	exit
end function

WifiCrack = function()
	host_comp = get_shell.host_computer
	if host_comp.wifi_networks("wlan0")[0] != null then
		interface = "wlan0"
	end if
	if host_comp.wifi_networks("eth0")[0] != null then
		interface = "eth0"
	end if
	devices = host_comp.network_devices.trim.split(" ")
	print(format_columns("[#] [INTERFACE] [CHIPSET] [MONITOR]\n" + "[0] [" + devices[0] + "] [" + devices[1] + "] [" + devices[2] + "]") + "\n")
	fh1 = 420000
	fh2 = 420000
	networks = []
	networks = host_comp.wifi_networks(interface)
	netlen = networks.len
	bssid = ""
	essid = ""
	bss = range(1, netlen)
	pwr = range(1, netlen)
	ess = range(1, netlen)
	ack = range(1, netlen)
	infonet = range(1, netlen)
	tack = ""
	countnet = ""
	for net in networks
		acks = ceil(300000/net.split(" ")[1].remove("%").val)
		if acks < fh2 then
			essid = net.split(" ")[2]
			fh2 = acks
		end if
	end for
	for net in networks
		countnet = networks.indexOf(net)
		acks = ceil(300000/net.split(" ")[1].remove("%").val)
		if acks < fh1 then
			bssid = net.split(" ")[0]
			fh1 = acks
		end if
		if countnet != netlen then
			bss[countnet] = net.split(" ")[0]
			pwr[countnet] = net.split(" ")[1]
			ess[countnet] = net.split(" ")[2]
			ack[countnet] = acks
		end if
		if countnet == 0 then
			infonet = "[#] [ESSID] [BSSID] [ACKs] [POWER] [STRENGTH]\n"
		end if
		if essid == net.split(" ")[2] then
			infonet = infonet + countnet + ") [" + net.split(" ")[2] + "] [" + net.split(" ")[0] + "] [" + acks + "] [" + net.split(" ")[1] + "] " + COLOUR_RED + "[STRONGEST]</color>\n"
			tack = acks
		else if pwr[countnet].remove("%").val >= 63 then
			infonet = infonet + countnet + ") [" + net.split(" ")[2] + "] [" + net.split(" ")[0] + "] [" + acks + "] [" + net.split(" ")[1] + "] " + COLOUR_ORANGE + "[STRONG]</color>\n"
		else if pwr[countnet].remove("%").val >= 42 then
			infonet = infonet + countnet + ") [" + net.split(" ")[2] + "] [" + net.split(" ")[0] + "] [" + acks + "] [" + net.split(" ")[1] + "] " + COLOUR_YELLOW + "[MEDIUM]</color>\n"
		else if pwr[countnet].remove("%").val < 42 then
			infonet = infonet + countnet + ") [" + net.split(" ")[2] + "] [" + net.split(" ")[0] + "] [" + acks + "] [" + net.split(" ")[1] + "] " + COLOUR_GREEN + "[WEAK]</color>\n"
		end if
		if acks != tack then
			acks = tack
		end if
	end for
	print(format_columns(infonet))
	cap = host_comp.File(current_path+"/file.cap")
	if cap then
		cap.delete
	end if
	cryptools.airmon("start", interface)
	print(COLOUR_YELLOW + "<b>-- Monitoring started --</b></color>")
	check = false
	while(check == false)
		selectnet = RequestInput("Enter a connection number to crack the wifi password: ").to_int
		if selectnet then
			if typeof(selectnet) == "number" and selectnet >= 0 and selectnet <= netlen then
				InfoMessage("You have selected <b>" + ess[selectnet] + "</b> network.</color>")
				InfoMessage("Target value of ACKs: [" + ack[selectnet] + "]</color>")
				if ack[selectnet] <= 7000 then
					InfoMessage("Estimated time: 1-2 minutes...</color>")
				else
					InfoMessage("Estimated time: 5-10 minutes... Could be longer...</color>")
				end if
				check = true
			else
				ErrorMessage("You have entered an invalid number.")
				check = false
				wait(2)
				MainMenu()
			end if
		else
			ErrorMessage("You must enter a valid number.")
			wait(2)
			MainMenu()
		end if
	end while
	print(COLOUR_YELLOW + "<b>-- Aireplay started --</b></color>")
	r1 = cryptools.aireplay(bss[selectnet], ess[selectnet], ack[selectnet])
	wait(2)
	if typeof(r1) == "string" then
		ErrorMessage("Variable r1 returned string! An issue has occured.")
		wait(2)
		MainMenu()
	end if
	pass = cryptools.aircrack(current_path+"/file.cap")
	if pass == "" then
		ErrorMessage("Variable pass has returned null in file.cap!")
		wait(2)
		MainMenu()
	end if
	print(COLOUR_YELLOW + "<b>-- Aircrack started --</b></color>")
	cap = host_comp.File(current_path+"/file.cap")
	if cap then cap.delete
	InfoMessage("Monitoring has stopped...")
	cryptools.airmon("stop", interface)
	check = false
	while(check == false)
		quest = RequestInput("Do you want to connect to the network? Y/n")
		if quest.lower == "y" then
			host_comp.connect_wifi(interface, bss[selectnet], ess[selectnet], pass)
			InfoMessage("You are now connected to the network! (Name: <b>" + COLOUR_RED + ess[selectnet] + "</b></color> - Password: <b>" + COLOUR_RED + pass + "</b></color>)")
			check = true
		else if quest.lower == "n" then
			InfoMessage("You are not connected to the network! (Name: <b>" + COLOUR_RED + ess[selectnet] + "</b></color> - Password: <b>" + COLOUR_RED + pass + "</b></color>)")
			check = true
		else
			check = false
			continue
		end if
		ContinueProgram()
	end while
end function

NMAP = function(target_ip)
	if not get_shell.host_computer.is_network_active then
		ErrorMessage("No connection to the internet.")
		wait(2)
		MainMenu()
	end if
	router = null
	ports = null
	if is_valid_ip(target_ip) then
		is_lan = is_lan_ip(target_ip)
		if is_lan then
			router = get_router
			ports = router.device_ports(target_ip)
		else
			router = get_router(target_ip)
			ports = router.used_ports
		end if
		if router == null then
			ErrorMessage("Target IP address not found. Null router.")
			wait(2)
			MainMenu()
		end if
		if typeof(ports) == "string" then
			ErrorMessage("An error occured with port return: [" + ports + "]")
			wait(2)
			MainMenu()
		end if
		if ports then
			info = COLOUR_PURPLE + "PORT STATE SERVICE VERSION LAN"
			print(COLOUR_YELLOW + "<b>-- NMAP started --</b></color>")
			InfoMessage("ESSID: <b>" + COLOUR_WHITE + router.essid_name + "</color></b>")
			InfoMessage("BSSID: <b>" + COLOUR_WHITE + router.bssid_name + "</color></b>")
			InfoMessage("Version: <b>v" + COLOUR_WHITE + router.kernel_version() + "</color></b>")
			firewall = router.firewall_rules
			if firewall == [] or firewall == null then
				InfoMessage("Firewall - <b>" + COLOUR_GREEN + "ALLOWED</b></color>")
			else
				InfoMessage("Firewall - <b>" + COLOUR_RED + "DENIED</b></color>")
				for rule in firewall
					print(COLOUR_RED + rule + "</color>")
				end for
			end if
			InfoMessage("Interesting ports on " + COLOUR_WHITE + "<b>" + target_ip + "</b></color>\n")
			if ports.len == 0 then
				InfoMessage("No open ports...")
				print(COLOUR_YELLOW + "<b>-- NMAP finished --</b></color>")
				ContinueProgram()
			end if
			ports = []
			for lan in router.devices_lan_ip
				ports = ports + router.device_ports(lan)
			end for
			for port in ports
				   service_info = router.port_info(port)
				   lan_ips = port.get_lan_ip
				   port_status = "open"
				   if(port.is_closed and not is_lan) then
					  port_status = "closed"
				   end if
				   info = info + "\n" + COLOUR_WHITE + port.port_number + " " + port_status + " " + service_info + " " + lan_ips
			end for
			print(format_columns(info) + "\n")
			print(COLOUR_YELLOW + "<b>-- NMAP finished --</b></color>")
			ContinueProgram()
		else
			print(COLOUR_YELLOW + "<b>-- NMAP started --</b></color>")
			InfoMessage("No open ports...")
			print(COLOUR_YELLOW + "<b>-- NMAP finished --</b></color>")
			ContinueProgram()
		end if
	end if
end function

ReverseShell = function()
	gen_request = null
	gen_input = RequestInput("Generate trojan binary to run on victim computer? (y/n) ")
	if gen_input.lower == "y" then
		gen_request = true
	else if gen_input.lower == "n" then
	else
		ReverseShell()
	end if
	if gen_request then
		ip_input = RequestInput("Your R-Shell Server IP: ")
		if ip_input then
			if is_valid_ip(ip_input) then
				port_input = RequestInput("Your R-Shell Server Port: ")
				port_input = port_input.to_int
				if port_input != null then
					if typeof(port_input) == "number" then
						troj_input = RequestInput("Enter Trojan Process Name: ")
						if troj_input then
							computer = get_shell.host_computer
							GenerateExploitTrojanScript(computer, ip_input, port_input, troj_input)
							InfoMessage("Trojan script created and saved at " + current_path + "/zenora_scripts/" + troj_input)
							wait(2)
							MainMenu()
						else
							ErrorMessage("You must enter a name for the trojan script and process!")
							wait(2)
							MainMenu()
						end if
					else
						ErrorMessage("You must enter a valid number for port!")
						wait(2)
						MainMenu()
					end if
				else
					ErrorMessage("Port null value received. Try again.")
					wait(2)
					MainMenu()
				end if
			else
				ErrorMessage("You have entered an invalid IP address.")
				wait(2)
				MainMenu()
			end if
		else
			ErrorMessage("You have not entered an R-Shell IP address.")
			wait(2)
			MainMenu()
		end if
	end if

	clear_screen
	print(COLOUR_WHITE + "<b>[--# " + COLOUR_YELLOW + "R-Shell Interface" + COLOUR_WHITE + " #--]</b></color>") // Title of the function
	
	// Get shell computer info
	get_shell_info = function(shell)
		computer = shell.host_computer
		return [computer.get_name, computer.public_ip, computer.local_ip, computer.active_net_card].join(" ")
	end function

	shells = metaxploit.rshell_server
	// if "shells" returned a unknown data type
	if typeof(shells) != "list" then
		ErrorMessage("Rshell server gave a unknown response! [" + shells + "]")
		wait(2)
		MainMenu()
	// If server has no incoming connections
	else if shells.len <= 0 or shells == null then
		ErrorMessage("Rshell server has no connections!")
		wait(2)
		MainMenu()
	end if
	// List incoming connections!
	info = COLOUR_PURPLE+"[#] [Device_Name] [Public_IP] [Local_Ip] [Connected_by]</color>\n"
	for index in range(1, shells.len)
		info = info + COLOUR_WHITE + index + ") " + get_shell_info(shells[index-1]) + "</color>\n"
	end for
	print(format_columns(info))
	print("")
	index = RequestInput("Index (0: Main Menu): ").val
	if index == 0 then MainMenu() // Return to MainMenu if user inputed 0 or if method .val got a string
	// check if index is not greater than shells.len
	if 1 > index or index > shells.len then 
		SyntaxMessage("Input Index between 0-"+shells.len)
		wait(2)
		ReverseShell()
	end if
	StartTerminal(shells[index-1], true)
	ContinueProgram()
end function

// Returns a FTP or SSH shell else go back to MainMenu
ConnectService = function()
	// Target IP
	ip_input = RequestInput("Target IP: ")
	if not is_valid_ip(ip_input) then
		ErrorMessage("You have entered an invalid target IP address.")
		wait(2)
		MainMenu()
	end if
	// Target Username
	username_input = RequestInput("Target Username: ")
	if not username_input then
		ErrorMessage("You have not entered a target username.")
		wait(2)
		MainMenu()
	end if
	// Target Password
	pass_input = RequestInput("Target Password: ")
	if not pass_input then
		ErrorMessage("You have not entered a target user password.")
		wait(2)
		MainMenu()
	end if
	// SSH or FTP Service
	service_input = RequestInput("Service (ssh/ftp):")

	// Connect Via SSH
	if service_input == "ssh" then
		shell = get_shell
		remote_shell = shell.connect_service(ip_input, PORT_SSH, username_input, pass_input, service_input)
		if typeof(remote_shell) == "string" or remote_shell == null then
			ErrorMessage("Failed to connect to remote shell via SSH.")
			wait(2)
		else
			InfoMessage("Connected successfully via SSH...")
			wait(0.5)
		end if
	// Connect Via FTP
	else if service_input == "ftp" then
		shell = get_shell
		remote_shell = shell.connect_service(ip_input, PORT_FTP, username_input, pass_input, service_input)
		if typeof(remote_shell) == "string" or remote_shell == null then
			ErrorMessage("Failed to connect to remote shell via FTP.")
			wait(2)
		else
			InfoMessage("Connected successfully via FTP...")
			wait(0.5)
		end if
	else
		ErrorMessage("You have entered an invalid service type!")
		wait(2)
		MainMenu()
	end if
	return remote_shell
end function

DisplayMenu = function(title, options)
	print(COLOUR_WHITE + "<b>[--# " + COLOUR_YELLOW + title + COLOUR_WHITE + " #--]</b></color>") // Title of the Menu
	// Print Options
	for index in range(1, options.len)
		option = options[index-1]
		if option isa map then
			index = option.indexes[0]
			option = option[index]
		end if
		print(COLOUR_WHITE + index +") " + COLOUR_ORANGE + option + "</color>")
	end for
	
	print(COLOUR_WHITE + "<b>[--# " + COLOUR_YELLOW + "Zenora Tool v" + version_number + COLOUR_WHITE + " #--]</b></color>\n") // Tool name with version
end function

// LOG CLEARING MENU
LogsMenu = function()
	if is_command then
		exit
	end if
	while true
		clear_screen
		options = ["Clear Logs (Remote SSH/FTP - Credentials Required)", "Clear Logs (Local)", "Main Menu", {0: "Exit Program"}]
		DisplayMenu("Clear Logs Menu", options)
		index = user_input(get_path)
		// Remote Logs
		if index == "1" then
			ClearLogs(ConnectService())
		// Local Logs
		else if index == "2" then
			ClearLogs(get_shell)
		// Main Menu
		else if index == "3" then
			MainMenu()
		// Exit Program
		else if index == "0" then
			exit
		end if
	end while
end function

ClearLogs = function(shell)
	if typeof(shell) == "computer" then computer = shell else computer = shell.host_computer // if shell by chance is a host_computer
	log_file = computer.File("/var/system.log")
	// if log_file doesnt exists
	if not log_file then
		ErrorMessage("Log file does not exist at /var/system.log!")
		wait(2)
		return
	end if
	// Check permission on log_file if can read else return
	if not log_file.has_permission("r") then
		ErrorMessage("You are unauthorized to access the log file. Permission denied.")
		wait(2)
		return
	end if
	// Create new "system.log" file on /root
	create_log = computer.touch("/root", "system.log")
	if typeof(create_log) == "string" then
		ErrorMessage("Log file creation is unsuccessful! [" + create_log + "]")
		wait(2)
	end if
	// Try to move new_log file to /var
	new_log = computer.File("/root/system.log")
	move_log = new_log.move("/var", "system.log")
	if typeof(move_log) == "string" then // if true try delete new_log
		ErrorMessage("Log file move to /var/ is unsuccessful! [" + move_log + "]")
		wait(2)
		move_log = new_log.delete
		if typeof(move_log) == "string" then
			ErrorMessage("Unable to remove created system.log file! [" + move_log + "]")
			wait(2)
		end if
	end if
	InfoMessage("Log file has been cleared successfully.")
	wait(2)
end function

is_library_file = function(target_input)
	if target_input.indexOf(".so") != null then
		shell = get_shell
		lib_file = shell.host_computer.File("/lib/" + target_input)
		if not lib_file then
			lib_file = shell.host_computer.File("/home/" + active_user + "/" + target_input)
		end if
		if lib_file then
			if lib_file.has_permission("r") then
				return true
			else
				ErrorMessage("You are not authorized to access file " + lib_file.path + ". Permission denied.")
				wait(2)
			end if
		else
			ErrorMessage("This library file does not exist.")
			wait(2)
		end if
	end if
end function

RemoteLocalHack = function()
	target_input = RequestInput("IP / Local Library (ex init.so): ")
	if target_input then
		optport = true
		optlan = false
		router = get_router
		router_ip = router.local_ip
		if is_valid_ip(target_input) then
			if is_lan_ip(target_input) then
				if router_ip == target_input then
					optport = false
					optlan = true
				end if
			end if
			globals.ip_addr = target_input
			if optport then
				port_input = RequestInput("Target Port: ")
				port_input = port_input.to_int
				if port_input != null then
					if typeof(port_input) == "number" then
						if port_input == 0 then
							optlan = true
							if is_lan_ip(target_input) and not router_ip == target_input then
								InfoMessage("Changing ip address exploitation to router " + router_ip + " on port 0.")
								wait(2)
								globals.ip_addr = router_ip
							end if
						end if
						globals.port_num = port_input
					else
						ErrorMessage("You must enter a valid number for port!")
						wait(2)
						MainMenu()
					end if
				else
					ErrorMessage("Port null value received. Try again.")
					wait(2)
					MainMenu()
				end if
			else
				globals.port_num = 0
			end if
			net_session = metaxploit.net_use(globals.ip_addr, globals.port_num)
			if not net_session then
				ErrorMessage("Unable to connect to net session.")
				wait(2)
				MainMenu()
			end if
			metaLib = net_session.dump_lib
		else if is_library_file(target_input) then
			if router_ip == get_shell.host_computer.local_ip then
				optlan = true
			end if
			lib = metaxploit.load("/lib/" + target_input)
			if not lib then
				lib = metaxploit.load("/home/" + active_user + "/" + target_input)
			end if
			if not lib then
				ErrorMessage("Unable to locate specified library file!")
				wait(2)
				MainMenu()
			end if
			metaLib = lib
		else
			ErrorMessage("Unrecognized user input. Try again!")
			wait(2)
			MainMenu()
		end if
		if optlan then
			lan_input = RequestInput("Target LAN IP (Optional): ")
			if lan_input then
				if is_lan_ip(lan_input) then
					globals.opt_var = lan_input
				else
					ErrorMessage("You must enter LAN format IP address!")
					wait(2)
					MainMenu()
				end if
			end if
		else
			pass_input = RequestInput("New Password (Optional): ")
			if pass_input then
				globals.opt_var = pass_input
			else
				globals.opt_var = null
			end if
		end if

		// Create IP-specific directory as soon as we have the IP
		computer = get_shell.host_computer
		ip_dir = null
		if is_lan_ip(globals.ip_addr) then
			ip_dir = computer.get_name + "-" + globals.ip_addr
		else
			ip_dir = globals.ip_addr
		end if
		
		// Create main IP directory
		if not computer.File(current_path + "/" + ip_dir) then
			computer.create_folder(current_path, ip_dir)
		end if

		// Log hack start with details
		PushExploitLogMessage("", false)
		PushExploitLogMessage("Begin hack attempt...")
		PushExploitLogMessage("Config:", false)
		PushExploitLogMessage("Target IP: " + globals.ip_addr, false)
		if globals.opt_var then
			if is_lan_ip(globals.opt_var) then
				PushExploitLogMessage("Target LAN IP: " + globals.opt_var, false)
			else
				PushExploitLogMessage("Optional Password: " + globals.opt_var, false)
			end if
		end if
		PushExploitLogMessage("Port: " + globals.port_num, true)

		if metaLib then
			BeginHack(metaLib)
		else
			ErrorMessage("metaLib failed to load!")
			wait(2)
			MainMenu()
		end if
	else
		ErrorMessage("You must enter a valid user input!")
		wait(2)
		MainMenu()
	end if
end function

UploadResult = function(filename, result, shell, remote_shell)
	if typeof(result) == "string" then
		result = shell.scp(filename, current_path + "/", remote_shell) // Retry at current_path folder instead of /lib, etc
		if typeof(result) == "string" then
			ErrorMessage("There was an issue uploading the file " + filename + " [" + result + "]")
			wait(0.5)
		else
			UploadResult(filename, result, shell, remote_shell)
		end if
	else
		InfoMessage("File " + filename + " has been uploaded successfully.")
		wait(0.5)
	end if
end function

UploadHack = function()
	shell = get_shell
	remote_shell = ConnectService()
	file = program_path
	result = shell.scp(program_path, "/bin/", remote_shell)
	wait(0.2)
	UploadResult(file, result, shell, remote_shell)
	file = "/lib/crypto.so"
	result = shell.scp(file, "/lib/", remote_shell)
	wait(0.2)
	UploadResult(file, result, shell, remote_shell)
	file = "/lib/metaxploit.so"
	result = shell.scp(file, "/lib/", remote_shell)
	wait(0.2)
	UploadResult(file, result, shell, remote_shell)
	file = "/usr/bin/ScanLan.exe"
	result = shell.scp(file, "/usr/bin/", remote_shell)
	wait(0.2)
	UploadResult(file, result, shell, remote_shell)
	file = "/usr/bin/ScanLan.exe"
	result = shell.scp(file, "/usr/bin/", remote_shell)
	wait(0.2)
	UploadResult(file, result, shell, remote_shell)
	ClearLogs(remote_shell)
	StartTerminal(remote_shell)
	ContinueProgram()
end function

RemoveResult = function(filename, result, shell)
	if result then
		if result.has_permission("r") then
			result.delete
			InfoMessage("File " + filename + " has been removed successfully.")
			wait(0.5)
		else
			ErrorMessage("You are not authorized to access file " + filename + ". Permission denied.")
			wait(0.5)
		end if
	else
		result = shell.host_computer.File(current_path + "/" + filename) // Retry at current_path folder instead of /lib, etc
		if result then
			RemoveResult(filename, result)
		else
			ErrorMessage("There was an error removing file " + filename + ". Does it exist?")
			wait(0.5)
		end if
	end if
end function

RemoveHack = function(is_remote)
	if is_remote then
		shell = ConnectService()
	else
		shell = get_shell
	end if
	file = program_path
	result = shell.host_computer.File(file)
	RemoveResult(file, result, shell)
	file = "/lib/crypto.so"
	result = shell.host_computer.File(file)
	RemoveResult(file, result, shell)
	file = "/lib/metaxploit.so"
	result = shell.host_computer.File(file)
	RemoveResult(file, result, shell)
	file = "/usr/bin/ScanLan.exe"
	result = shell.host_computer.File(file)
	RemoveResult(file, result, shell)
	file = current_path + "/zenora_data/" 
	result = shell.host_computer.File(file)
	RemoveResult(file, result, shell)
	file = current_path + "/zenora_scripts/" 
	result = shell.host_computer.File(file)
	RemoveResult(file, result, shell)
	ClearLogs(shell)
	if is_remote then
		StartTerminal(shell)
	end if
	ContinueProgram()
end function

RetrieveResult = function(file, result)
	if result then
		   if result.has_permission("r") then
			InfoMessage("Attempting to decipher file " + file + "...")
			file_content = result.get_content.split("\n")
			file_split = file_content[0].split(":")
			wait(0.5)
			decipher_pass = GetPassword(file_split)
			InfoMessage("User - <b>" + file_split[0] + "</b>")
			InfoMessage("Pass - <b>" + decipher_pass + "</b>")
			wait(0.5)
		else
			ErrorMessage("You are not authorized to access file " + file + ". Permission denied.")
			wait(0.5)
		end if
	else
		ErrorMessage("There was an error retrieving file " + file + ". Does it exist?")
		wait(0.5)
	end if
end function

RetrieveBankMail = function(is_remote)
	if is_remote then
		shell = ConnectService()
	else
		shell = get_shell
	end if
	home_folder = shell.host_computer.File("/home")
	if home_folder then
		for folder in home_folder.get_folders
			user_folder = folder.name
			if user_folder != "guest" then
				file = "/home/" + user_folder + "/Config/Bank.txt"
				result = shell.host_computer.File(file)
				RetrieveResult(file, result)
				file =  "/home/" + user_folder + "/Config/Mail.txt"
				result = shell.host_computer.File(file)
				RetrieveResult(file, result)
			end if
		end for
	else
		ErrorMessage("Home folder does not exist!")
	end if
	ClearLogs(shell)
	if is_remote then
		StartTerminal(shell)
	end if
	is_remote = false
	ContinueProgram()
end function

HackManagementMenu = function()
	if is_command then
		exit
	end if
	while true
		clear_screen
		options = ["Upload Hacks (Remote SSH/FTP - Credentials Required)"]
		options.push("Remove Hacks (Local)")
		options.push("Remove Hacks (Remote SSH/FTP - Credentials Required)")
		options.push("Main Menu")
		options.push({0: "Exit Program"})
		DisplayMenu("Hack File Management Menu", options)
		
		index = user_input(get_path)
		
		// Upload Hacks (Remote)
		if index == "1" then
			UploadHack()
		// Remove Hacks (Local)
		else if index == "2" then
			confirm_input = RequestInput("Are you sure you want to remove many files from local machine? (y/n)") // Confirm incase of accident (yep, it happened twice)
			if confirm_input.lower == "y" then
				RemoveHack()
			else if confirm_input.lower == "n" then
				HackManagementMenu()
			else
				continue
			end if
		// Remove Hacks (Remote)
		else if index == "3" then
			RemoveHack(true)
		// Main Menu
		else if index == "4" then
			MainMenu()
		// Exit Program
		else if index == "0" then
			exit
		end if
	end while
end function

BankMailManagementMenu = function()
	if is_command then
		exit
	end if
	while true
		clear_screen
		options = ["Retrieve Bank & Mail (Remote SSH/FTP - Credentials Required)"]
		options.push("Retrieve Bank & Mail (Local)")
		options.push("Main Menu")
		options.push({0: "Exit Program"})
		DisplayMenu("Bank & Mail Management Menu", options)
		
		index = user_input(get_path)
		
		// Retrieve Information (Remote)
		if index == "1" then
			RetrieveBankMail(true)
		// Retrieve Information (Local)
		else if index == "2" then
			RetrieveBankMail()
		// Main Menu
		else if index == "3" then
			MainMenu()
		// Exit Program
		else if index== "0" then
			exit
		end if
	end while
end function

GetPassword = function(userPass)
	if userPass.len != 2 then
		ErrorMessage("Decipher failed. Wrong syntax!")
		wait(2)
		MainMenu()
	end if
    // This is for decrypting root passwords during exploits
    return crypto.decipher(userPass[1])
end function

DecipherHash = function(hash)
	if hash then
		decipher_hash = hash
	else
		decipher_hash = RequestInput("Enter Path/Hash: ")
	end if
	if decipher_hash then
		file = get_shell.host_computer.File(decipher_hash)
		if file then
			if not file.has_permission("r") then
				ErrorMessage("You are not unauthorized to access file <b>" + decipher_hash + "</b>. Permission denied.")
				wait(2)
				MainMenu()
			end if
			if file.is_binary then
				ErrorMessage("Unable to read <b>" + decipher_hash + "</b> binary file.")
				wait(2)
				MainMenu()
			end if
			if file.get_content.len == 0 then
				ErrorMessage("File <b>" + decipher_hash + "</b> is empty.")
				wait(2)
				MainMenu()
			end if
			lines = file.get_content.split("\n")
		else if decipher_hash.len > 33 then
			lines = [decipher_hash]
		else
			ErrorMessage("File not found or incorrect hash.")
			wait(2)
			MainMenu()
		end if
		if lines != null then
			for line in lines
				file_info = line.split(":")
				if file_info[1].len == 32 then
					password = GetPassword(file_info)
					if not password then
						ErrorMessage("Password not found.")
						wait(2)
					else
						print(file_info[0])
						print(password)
					end if
				else
					ErrorMessage("Incorrect hash!")
					wait(0.5)
					continue
				end if
			end for
			ContinueProgram()
		end if
	else
		ErrorMessage("You must enter a decipher file or hash in pass format!")
		wait(2)
		MainMenu()
	end if
end function

// meta = include_lib(path_to_metaxploit.so)
// if is_lan_ip then it's local, so net_session = meta.net_use(lan_ip) with no port is great // or net_session = meta.net_use(target ip, target port)
// then we can dump the lib. metaLib = net_session.dump_lib
// BeginHack = function(metaLib) for example
// then we can buffer overflow the lib.
// result = metaLib.overflow(memory address, exploit) for example
// then we get the result of object types from here

ExploitShell = function(shell)
	ExploitComputer(shell.host_computer)
	HandleExploitResult(shell, globals.metaLib, globals.exploit_data.memAddress, globals.exploit_data.unsecValue, globals.ip_addr, true, globals.exploit_data.rootPass)
end function

ExploitComputer = function(computer)
	computerLogs = ["-- Exploit Computer --",
	"Computer name: " + computer.get_name,
	"Local IP: " + computer.local_ip,
	"Connected by: " + computer.active_net_card]
	InfoMessage(computerLogs.join(char(10)))
	PushExploitLogMessage(computerLogs.join(char(10)))
	ExploitFile(computer.File("/"))
end function

// Add this at the top with other globals
exploited_machines = []

ExploitFile = function(file)
	while file.name != "/"
		file = file.parent
	end while
	files = ListTree(file, false)
	for f in files["files"]
		// if file is Mail.txt or Bank.txt
		if f.name == "Mail.txt" or f.name == "Bank.txt" then
			newFile = new file_info
			newFile.name = f.name
			newFile.path = f.path
			newFile.content = f.get_content

            // Calculate isLastFile before using it
            isLastFile = globals.exploit_data.files.indexOf(newFile) == globals.exploit_data.files.len

			if (globals.exploit_data.files.indexOf(newFile) != null) then
                PushExploitLogMessage("Already found this file: " + f.path + ", skipping...", isLastFile)
				InfoMessage("File already scanned: " + f.path + ", skipping...")
				continue
			end if
			PushExploitLogMessage("Found file: " + f.path, false)
			InfoMessage("Found file: " + f.path)
			if not file.has_permission("r") then
				ErrorMessage("You are unauthorized to access this file. Permission denied.")
				wait(1)
				continue
			end if
			print(COLOUR_WHITE + "   -> </color>" + f.get_content)

            isLastFile = globals.exploit_data.files.indexOf(newFile) == globals.exploit_data.files.len
            PushExploitLogMessage("Contents: " + f.get_content, isLastFile)

			TrackFile(f.path, f.get_content, f.name)
		// if file is passwd
		else if f.path == "/etc/passwd" then
			InfoMessage("Found file: " + f.path)
			if not f.has_permission("r") then
				ErrorMessage("You are unauthorized to access the password file. Permission denied.")
				wait(1)
				continue
			end if
			pass_content = f.get_content.split("\n")
			if globals.exploit_data.passContent == pass_content then
				PushExploitLogMessage("Already found this passwd file, skipping..")
				continue
			end if
			PushExploitLogMessage("Found Password(s): " + pass_content + char(10) + "Attempting decipher...")
			InfoMessage("Attempting to decipher password...")
			globals.exploit_data.passContent = pass_content
			wait(1)
			pass = GetPassword(pass_content[0].split(":"))
            PushExploitLogMessage("[ROOT PASSWORD] " + pass)
            InfoMessage("[ROOT PASSWORD]: <b>" + pass + "</b>")
			globals.exploit_data.rootPass = pass
			wait(2)
		end if
	end for

    // Get machine identifier from the computer object
    computer = get_shell.host_computer
    machine_id = computer.get_name + "_" + computer.local_ip
    
    // Just track the machine, don't show file structure yet
    if globals.exploited_machines.indexOf(machine_id) == null then
        globals.exploited_machines.push(machine_id)
    end if
end function

// ScanMetalib - Scans metalib and returns a list[map] -> [ {"memory": str, "unsecValue": str} ]
ScanMetalib = function(mLib)
	info = []
	unscanned_zones = []
	memories = metaxploit.scan(mLib)
	for mem_addr in memories
		vuln_strings = metaxploit.scan_address(mLib, mem_addr)
		// Unable to get vulnerabilities
		if not vuln_strings then
			unscanned_zones.push(mem_addr)
			continue
		end if
		// Find the unsecure value (exploit)
		for line in vuln_strings.split("\n")
			if not line.startswith("Unsafe check: ") then continue
			info.push({"memory": mem_addr, "unsecValue": line[line.indexOf("<b>")+3:line.indexOf("</b>")]})
		end for
	end for

	// If we found unscanned zones, display them
	if unscanned_zones.len > 0 then
		msg = "One or more memory zones with possible vulnerabilities could not be scanned. Update your Metaxploit library"
		msg = msg + char(10) + "Unscanned zones:"
		for zone in unscanned_zones
			msg = msg + char(10) + "[" + zone + "]"
		end for
		ErrorMessage(msg)
		wait(2)
	end if

	return info
end function

BeginHack = function(mLib)
	pass = false
	computer = get_shell.host_computer

	// Create IP-specific directory in current directory before starting scan
	ip_dir = null
	if is_lan_ip(globals.ip_addr) then
		ip_dir = computer.get_name + "-" + globals.ip_addr
	else
		ip_dir = globals.ip_addr
	end if
	
	// Create main IP directory
	if not computer.File(current_path + "/" + ip_dir) then
		computer.create_folder(current_path, ip_dir)
	end if

	print(COLOUR_YELLOW + "<b>-- Scan started --</b></color>")
	print(COLOUR_ORANGE + "Library: " + COLOUR_WHITE + mLib.lib_name + COLOUR_ORANGE + " - Version: " + COLOUR_WHITE + mLib.version + "</color>")
	
	// Log library scan start
	PushExploitLogMessage("Starting library scan: " + mLib.lib_name + " v" + mLib.version)
	
	memories = ScanMetalib(mLib)
	globals.metaLib = mLib

	// Log all found memory addresses and their unsecure values
	if memories.len > 0 then
		msg = "Found " + memories.len + " memory locations to exploit:"
		for memory in memories
			msg = msg + char(10) + "[" + memory.memory + "] -> " + memory.unsecValue
		end for
		PushExploitLogMessage(msg)
		InfoMessage(COLOUR_YELLOW + msg + "</color>")
	else
		PushExploitLogMessage("No exploitable memory locations found")
		print(COLOUR_RED + "No exploitable memory locations found</color>")
	end if

	// Track exploit results for summary
	exploit_results = []

	for memory in memories
		mem_addr = memory.memory
		unsecValue = memory.unsecValue
		globals.exploit_data.unsecValue = unsecValue
		globals.exploit_data.memAddress = mem_addr
		result = null
		if globals.opt_var == null then
			PushExploitLogMessage("Attempting overflow.", false)
			InfoMessage("Attempting overflow.")
			result = mLib.overflow(mem_addr, unsecValue)
			if not result then
				PushExploitLogMessage("Failed..")
			else if not result and is_lan_ip(globals.ip_addr) then
				PushExploitLogMessage("Attempting overflow on Local IP", false)
				InfoMessage(char(10) + "Attempting overflow on Local IP")
				// If result fails try with same local ip in overflow
				result = mLib.overflow(mem_addr, unsecValue, globals.ip_addr)
				if not result then
					PushExploitLogMessage("Failed..")
				end if
			end if
		else
			PushExploitLogMessage("Attempting overflow on " + globals.ip_addr + " [" + mem_addr + "] " + unsecValue + " - with optional value: " + globals.opt_var, false)
			InfoMessage(char(10) + "Attempting overflow on " + globals.ip_addr + " [" + mem_addr + "] " + unsecValue + " - with optional value: " + globals.opt_var)
			result = mLib.overflow(mem_addr, unsecValue, globals.opt_var)
			if result then
				if result and is_lan_ip(globals.opt_var) then
					InfoMessage("Optional LAN IP Called: <b>" + globals.opt_var + "</b>")
					wait(0.5)
				else
					InfoMessage("Optional Password Called: <b>" + globals.opt_var + "</b>")
					wait(0.5)
				end if
			else
				PushExploitLogMessage("Failed..")
				PushExploitLogMessage("Attempting overflow on " + globals.ip_addr + " [" + mem_addr + "] " + unsecValue + " - ", false)
				InfoMessage(char(10) + "Attempting overflow on " + globals.ip_addr + " [" + mem_addr + "] " + unsecValue)
				result = mLib.overflow(mem_addr, unsecValue)
				if not result then
					PushExploitLogMessage("Failed..")
			end if
		end if
		end if

		// Track the result for summary
		status = "Failed"
		if result then
			if typeof(result) == "shell" then
				status = "Shell Access"
				if globals.exploit_data.rootPass then
					status = status + " (Root)"
				end if
			else if typeof(result) == "computer" then
				status = "Computer Access"
				if globals.exploit_data.rootPass then
					status = status + " (Root)"
				end if
			else if typeof(result) == "file" then
				status = "File Access"
				if globals.exploit_data.rootPass then
					status = status + " (Root)"
				end if
			end if
		end if
		exploit_results.push({"memory": mem_addr, "unsecValue": unsecValue, "status": status})

		if not result then
			PushExploitLogMessage("-- Attack unsuccessful --")
			WarningMessage("Exploit attempt failed.")
			print()
			wait(0.2)
			continue
		end if
		useNewLine = memory
		HandleExploitResult(result, mLib, mem_addr, unsecValue, globals.ip_addr, true)
		// Shell
		if typeof(result) == "shell" then
			ExploitShell(result)
		// Computer
		else if typeof(result) == "computer" then
			ExploitComputer(result)
		// File
		else if typeof(result) == "file" then
			ExploitFile(result)
		else
			ErrorMessage("Unsupported object returned!" + char(10))
		end if
		end for

	// Show file structure for all exploited machines
	print(COLOUR_YELLOW + "<b>-- File Structure Summary --</b></color>")
	for machine_id in globals.exploited_machines
		computer = get_shell.host_computer
		PushExploitLogMessage("File structure for machine: " + machine_id)
		print(COLOUR_WHITE + "Machine: " + machine_id + "</color>")
		ListTree(computer.File("/"), true)
	end for
	print("")
	// Display and log exploit summary
	summary = "===Exploit Summary ==="
	for result in exploit_results
		summary = summary + char(10) + "[" + result.memory + "] [" + result.status + "] -> " + result.unsecValue
	end for
	if globals.exploit_data.rootPass then
		summary = summary + char(10) + char(10) + "[ROOT PASSWORD: " + globals.exploit_data.rootPass + "]"
	end if
	PushExploitLogMessage(summary + char(10))
	print(COLOUR_YELLOW + "<b>" + summary + "</b></color>")

		ResetGlobals()
		print(COLOUR_ORANGE + "Library: " + COLOUR_WHITE + mLib.lib_name + COLOUR_ORANGE + " - Version: " + COLOUR_WHITE + mLib.version + "</color>")
		print(COLOUR_YELLOW + "<b>-- Scan finished --</b></color>")
		wait(2)
		ContinueProgram()
end function

ResetGlobals = function()
	globals.main_input = null
	globals.ip_addr = null
	globals.port_num = null
	globals.exploit_data.unsecValue = null
	globals.exploit_data.memAddress = null
	globals.exploit_data.rootPass = null
	globals.exploit_data.passContent = null
	globals.exploit_data.files = []
	globals.metaLib = null
	globals.is_command = false
	globals.comp = get_shell.host_computer.File("/")
	globals.exploited_machines = [] // Reset the exploited machines list
end function

HandleExploitResult = function(result, mLib, mem_addr, exploit, target_ip, is_valid, root_pass = null)
	computer = get_shell.host_computer
	
	if not target_ip or not is_valid_ip(target_ip) then
		if is_lan_ip(globals.opt_var) then
			target_ip = globals.opt_var
		else
			target_ip = computer.local_ip
		end if
	end if
	AddExploitDetailsToSaveEntry(computer, result, mLib, mem_addr, exploit, target_ip, is_valid, root_pass)
	if is_valid then
		GenerateExploitReconnectScript(computer, result, mLib, mem_addr, exploit, target_ip)
	end if
	PrintExploitDetails(target_ip, mem_addr, exploit, globals.exploit_data.rootPass, mLib)
end function

PrintExploitDetails = function(ip, addr, exploit, password, mLib)
	print("\n" + COLOUR_YELLOW + "=== Exploit Details ===" + COLOUR_WHITE)
	print("Target IP: " + ip + ":" + globals.port_num)
	print("Memory Address: " + addr)
	print("Exploit: " + exploit)
	print("Password: " + password)
	print("Library: " + mLib.lib_name + " v" + mLib.version)
	print("GeneratedOn: " + current_date)
	print("====================" + "</color>\n")
end function

TrackFile = function(path, content, name = "")
	newFile = new file_info
	newFile.name = name
	newFile.path = path
	newFile.content = content
	if(globals.exploit_data.files.indexOf(newFile) == null) then
		// Add file info to exploit_data
		globals.exploit_data.files.push(newFile)
		return
	end if
	
end function

AddExploitDetailsToSaveEntry = function(computer, result, mLib, mem_addr, exploit, target_ip, is_valid, root_pass = null)
	// Save exploit details to LOCAL file
	status = "Attempting."
	if is_valid then
		status = "## Valid ##"
	end if
	save_entry = ["",
		"Status: " + status,
		"IP_Address: " + target_ip,
		"Port: " + globals.port_num,
		"Memory_Address: " + mem_addr,
		"Exploit: " + exploit,
		"Library: " + mLib.lib_name + " v" + mLib.version,
		"GeneratedOn: " + current_date]
		if is_valid and globals.exploit_data.passContent then
			save_entry.push("Passwords: " + globals.exploit_data.passContent)
		end if
		
		if root_pass then
			save_entry.push("[ROOT PASSWORD: " + root_pass + "]")
		end if
		if is_valid and globals.exploit_data.files.len > 0 then
			save_entry.push("Files: ")
			for file in globals.exploit_data.files
				save_entry.push("    " + file.path + " - " + file.content)
			end for
			save_entry.push("")
		end if
		save_entry = save_entry.join(char(10))
		PushExploitLogMessage(save_entry)
end function

PushExploitLogMessage = function(message, useNewLine = true)
    // Create IP-specific directory for logs
    ip_dir = null
    if is_lan_ip(globals.ip_addr) then
        ip_dir = get_shell.host_computer.get_name + "-" + globals.ip_addr
    else
        ip_dir = globals.ip_addr
    end if
    
    // Append to IP-specific log file
    log_path = current_path + "/" + ip_dir + "/exploit_log.txt"
	computer = get_shell.host_computer
    log_file = computer.File(log_path)
    if not log_file then
        computer.touch(current_path + "/" + ip_dir, "exploit_log.txt")
        wait(1)
	end if
    if log_file then
		if(useNewLine) then
			message = message + char(10)
		end if
        log_file.set_content(log_file.get_content + char(10) + message)
	end if
end function

GenerateExploitReconnectScript = function(computer, result, mLib, mem_addr, exploit, target_ip)
	// Only generate reconnect script if we have a successful exploit
	if typeof(result) != "shell" and typeof(result) != "computer" then
		return
	end if

	ip_dir = null
	if is_lan_ip(target_ip) then
		ip_dir = computer.get_name + "-" + target_ip
	else
		ip_dir = target_ip
	end if

	// For local IP exploits, create a subfolder with the local IP
	script_dir = current_path + "/" + ip_dir
	if is_lan_ip(target_ip) and globals.opt_var and is_lan_ip(globals.opt_var) then
		local_ip_dir = globals.opt_var
		script_dir = script_dir + "/" + local_ip_dir
		if not computer.File(script_dir) then
			computer.create_folder(current_path + "/" + ip_dir, local_ip_dir)
		end if
	end if

	// Create base name using memory address and unsecValue
	base_name = mem_addr + "_" + exploit
	
	// If we have root access, create a special root reconnect file
	if globals.exploit_data.rootPass then
		// Create root reconnect name
		base_name = "root_" + base_name
	else
		// Check if this exact exploit combination already exists
		if computer.File(script_dir + "/" + base_name + ".src") or computer.File(script_dir + "/" + base_name) then
			// If it exists, don't create another one
			return
		end if
	end if

	// Generate LOCAL reconnect script
	script_content = ["// Zenora Tool - Reconnect Script",
		"// Exploit: " + exploit,
		"// Memory Address: " + mem_addr,
		"// Target IP: " + target_ip,
		"// GeneratedOn: " + current_date,
		"",
		"pkg = get_custom_object",
		"",
		"if not pkg.hasIndex(""metaxploit"") then",
		"	metaxploit = include_lib(""/lib/metaxploit.so"")",
		"	if not metaxploit then metaxploit = include_lib(current_path + ""/metaxploit.so"")",
		"	if not metaxploit then exit(""Cannot find metaxploit library in lib or current path folder."")",
		"end if",
		"",
		"shell = get_shell",
		"if not shell then exit(""No shell"")",
		"	",
		"	target_ip = """ + target_ip + """",
		"	mem_addr = """ + mem_addr + """",
		"	exploit = """ + exploit + """",
		"	password = """ + opt_var + """",
		"	",
		"	net_session = metaxploit.net_use(""" + target_ip + """, " + globals.port_num + ")",
		"	metaLib = net_session.dump_lib",
		"	",
		"	result = metaLib.overflow(mem_addr, exploit, password)"]

	if globals.exploit_data.rootPass then
		script_content.push("		print("" " + COLOUR_YELLOW + "To elevate to root: <b>sudo -s [" + globals.exploit_data.rootPass + "]</b></color>"")")
		else
		script_content.push("		print("" " + COLOUR_ORANGE + "Root password not found. Try to elevate manually.</color>"")")
	end if
	
	script_content.push("if typeof(result) == ""shell"" then result.start_terminal")

	// Save script locally with descriptive name
	script_path = script_dir + "/" + base_name + ".src"
	script_file = computer.File(script_path)
	if not script_file then
		computer.touch(script_dir, base_name + ".src")
		script_file = computer.File(script_path)
	end if
	if script_file then script_file.set_content(script_content.join(char(10)))

	// Build the script and delete the .src file
	get_shell.build(script_path, script_dir, 1)
	script_file.delete
end function

GenerateExploitTrojanScript = function(computer, rshell_ip, rshell_port, trojan_name) // R-Shell trojan backdoor - Port 1222 is recommended
	if not computer then
		computer = get_shell.host_computer
	end if
	if not rshell_port then
		rshell_port = 1222
	end if
	if not trojan_name then
		trojan_name = "trojan"
	end if
	troj_dir = current_path + "/zenora_scripts/"
	if not computer.File(troj_dir) then
		computer.create_folder(current_path, "zenora_scripts")
	end if
	// Generate LOCAL trojan script - Put and run it on target pc for backdoor access (Needs R-Shell set up on your server - not main computer)
	script_content = ["// Zenora Tool - Trojan Script",
		"// R-Shell IP: " + rshell_ip,
		"// R-Shell Port: " + rshell_port,
		"// Trojan Name: " + trojan_name,
		"// GeneratedOn: " + current_date,
		"",
		"pkg = get_custom_object",
		"",
		"if not pkg.hasIndex(""metaxploit"") then",
		"	metaxploit = include_lib(""/lib/metaxploit.so"")",
		"	if not metaxploit then metaxploit = include_lib(current_path + ""/metaxploit.so"")",
		"	if not metaxploit then exit(""Cannot find metaxploit library in lib or current path folder."")",
		"end if",
		"",
		"rshell_ip = """ + rshell_ip + """",
		"trojan_name = """ + trojan_name + """",
		"metaxploit.rshell_client(rshell_ip, " + rshell_port + ", trojan_name)"]

	// Save script locally
	script_path = current_path + "/zenora_scripts/" + trojan_name + ".src"
	script_file = computer.File(script_path)
	if not script_file then
		computer.touch(troj_dir, trojan_name + ".src")
		script_file = computer.File(script_path)
	end if
	if script_file then script_file.set_content(script_content.join(char(10)))

	get_shell.build(script_path, current_path + "/zenora_scripts/", 1)
	script_file.delete
end function

MainMenu = function() // MAIN MENU - FIRST MENU
	if is_command then
		exit
	end if
	while true
		clear_screen
		options  =  ["Remote & Local Hack"]
		options.push("Hack File Management") // upload files remotely. remove files locally or remotely (remote ssh or ftp port required)
		options.push("Bank & Mail Management") 
		options.push("Decipher Hash")
		options.push("List Directory Files")
		options.push("NMAP IP Address")
		options.push("Wifi Cracker")
		options.push("R-Shell Interface")
		options.push("Clear Logs") // clear logs locally or remotely (remote ssh or ftp port required)
		options.push({0: "Exit Program"})
		DisplayMenu("Main Menu", options)
		
		host_comp = get_shell.host_computer
		index = user_input(get_path)
		
		// Remote & Local IP Port Hack
		if index == "1" then
			RemoteLocalHack()
		// Hack File Management
		else if index == "2" then
			HackManagementMenu()
		// Bank & Mail Management
		else if index == "3" then
			BankMailManagementMenu()
		else if index == "4" then
			DecipherHash()
		// List Directory Files
		else if index == "5" then
			location_input = RequestInput("Path Location: ")
			// If user inputed nothing
			if not location_input then
				SyntaxMessage("Must input a path!")
				wait(2)
				MainMenu()
			end if
			path_result = host_comp.File(location_input)
			ListTree(path_result)
			ContinueProgram()
		// NMAP IP Address
		else if index == "6" then
			nmap_input = RequestInput("Target IP: ")
			NMAP(nmap_input)
		// Wifi Cracker
		else if index == "7" then
			WifiCrack()
		// R-Shell Interface
		else if index == "8" then
			ReverseShell()
		// Clear Logs
		else if index == "9" then
			LogsMenu()
		// Exit Program
		else if index == "0" then
			exit
		end if
	end while
end function

ContinueProgram = function() // Continue? y = Go back to main menu - n = Quit program (y and n are case insensitive)
	if is_command then
		exit
	end if
	continue_input = RequestInput("Continue to Main Menu? y/n")
	if continue_input.lower == "y" then
		MainMenu()
	else if continue_input.lower == "n" then
		exit
	else
		ContinueProgram()
	end if
end function

ListTree = function(file, print_directory=true)
	if not file then
		ErrorMessage("Path doesnt exist")
		wait(2)
		MainMenu()
	end if
	permission = COLOUR_WHITE+"|_"+file.permissions.replace("-", "_")
	if print_directory then print(permission + COLOUR_BLUE + file.path + "</color>")
	folders = {"files": [], "binary": []}

	list_dir = function(file)
		files = file.get_folders + file.get_files
		for f in files
			spaces = " "*(f.path.split("/").len-1)
			permission = spaces+COLOUR_WHITE+"|_"+f.permissions.replace("-", "_")			
			// file is a folder
			if f.is_folder then
				if print_directory then print(permission + " " + COLOUR_BLUE+ f.name() + "</color></b>")
				list_dir(f)
			// file is a binary
			else if f.is_binary then
				if print_directory then print(permission + "</b> " + COLOUR_PURPLE + f.name + COLOUR_YELLOW + "*</color>")
				outer.folders["binary"].push(f)
			// well file is file :)
			else
				if print_directory then print(permission + "</b> " + COLOUR_PURPLE + f.name + "</color>")
				outer.folders["files"].push(f)
			end if
		end for
	end function
	list_dir(file)

	if print_directory then
		PushExploitLogMessage(char(10) + "Listing files in " + file.path + " directory...", false)
		PushExploitLogMessage("Total files: " + folders["files"].len + " - Total binaries: " + folders["binary"].len, true)
		PushExploitLogMessage("Files:", false)
		for f in folders["files"]
			PushExploitLogMessage("   " + f.path + " - " + f.permissions.replace("-", "_"), false)
		end for
		PushExploitLogMessage("", false)
		PushExploitLogMessage("Binaries:", false)
		for f in folders["binary"]
			PushExploitLogMessage("   " + f.path + " - " + f.permissions.replace("-", "_"), false)
		end for
		PushExploitLogMessage("", false)
	end if
	
	return folders
end function

if params.len > 0 then
	is_command = true
	if params[0] == "-h" then // Help option - lists shortcut commands
		InfoMessage(program_path.split("/")[-1] + " -l <optional: path> - List directory")
		InfoMessage(program_path.split("/")[-1] + " -n <target ip> - Show NMAP")
		InfoMessage(program_path.split("/")[-1] + " -d <decipher hash> - Decipher option")
		InfoMessage(program_path.split("/")[-1] + " -w - Attempts Wifi cracking")
		InfoMessage(program_path.split("/")[-1] + " -v - Get current version")
		exit
	else if params[0] == "-l" then // ls shortcut
		if not RequestAccess() then exit
		if params.len > 1 then
			input_path = get_shell.host_computer.File(params[1])
			if input_path then
				if input_path.has_permission("r") then
					InfoMessage("Showing " + params[1] + " path...")
					wait(1)
					ListTree(input_path)
					ContinueProgram()
				else
					ErrorMessage("You are unauthorized to access " + params[1] + ". Permission denied.")
					exit
				end if
			else
				ErrorMessage("You have specified an incorrect path!")
				SyntaxMessage(program_path.split("/")[-1] + " -l <path location>") 
				exit
			end if
		else
			current = get_shell.host_computer.File(current_path)
			InfoMessage("Showing current path...")
			wait(1)
			ListTree(current)
			ContinueProgram()
		end if
	else if params[0] == "-n" then // NMAP
		if not RequestAccess() then exit
		if params.len > 1 then
			if is_valid_ip(params[1]) then
				NMAP(params[1])
			else
				ErrorMessage("You have entered an invalid target IP address.")
				exit
			end if
		else
			ErrorMessage("You have not entered a target IP address.")
			SyntaxMessage(program_path.split("/")[-1] + " -n <target ip>")
			exit
		end if
	else if params[0] == "-w" then // Wifi Cracking
		if not RequestAccess() then exit
		WifiCrack()
	else if params[0] == "-d" then // Decipher
		if not RequestAccess() then exit
		if params.len > 1 then
			DecipherHash(params[1])
		else
			ErrorMessage("You must enter a decipher hash.")
			SyntaxMessage(program_path.split("/")[-1] + " -d <decipher hash>")
			exit
		end if
	else if params[0] == "-v" or params[0] == "--version" then
		InfoMessage("Zenora - v" + version_number)
		exit
	else
		ErrorMessage("That command is not recognized!")
		exit
	end if
end if

if main_input == null then
	if not is_command then
        // Run first time setup before requesting access
        CheckFirstRun()
        if not RequestAccess() then exit
		MainMenu()
	else
		exit
	end if
end if

